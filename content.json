{"pages":[],"posts":[{"title":"8086 8088 寄存器、标志位","text":"内部寄存器的类型含14个16位寄存器，按功能可分为三类： 8个通用寄存器 4个段寄存器 2个控制寄存器 不管是哪一个，8位寄存器中存放的均为运算的数据。 通用寄存器 数据寄存器（AX BX CX DX） 地址指针寄存器（SP BP） 变址寄存器（SI DI） 8088/8086含有4个16位数据寄存器，4个数据寄存器分别可分为2个独立的8位寄存器 ，一共可分为8个8位寄存器，即： AX —— AH, AL BX —— BH, BL CX —— CH, CL DX —— DH, DL 全部通用寄存器中，只有AX和CX中的内容一定为参加运算的数据,，其余通用寄春器中的内容可能是数据，也可能是存放数据的地址。 数据寄存器特有的习惯用法： AX：累加器 所有I/O指令都通过AX与接口传送信息，中间运算结果也多放于AX中 BX：基址寄存器 在间接寻址中用于存放基址 CX：计数寄存器 用于在循环或串操作指令中存放计数值 DX：数据寄存器 在间接寻址的I/O指令中存放I/O端口地址，在32位乘法运算时，存放高16位数 地址指针寄存器SP：堆栈指针寄存器，其内容为栈顶的偏移地址。 BP：基址指针寄存器，常用于在访问内存时存放内存单元的偏移地址。 在有堆栈操作的时候，SP肯定被专用，但BP不一定。在没有堆栈的指令程序操作中，SP也可以被用作通用寄存器。 BX与BP在应用上的区别： 共同点都是可以用来存放某个单元的地址 作为基址寄存器，用BX表示所寻找的数据在数据段，用BP则表示在堆栈段 变址寄存器SI：源变址寄存器 DI：目标变址寄存器 变址寄存器在指令中常用于存放数据在内存中的地址 控制寄存器IP：指令指针寄存器，其内容为下一条要取的指令的偏移地址。 FLAGS：标志寄存器，存放运算结果的特征 整体来讲是一个16位寄存器，但只有9位是有意义的，其他7位都是空闲位；这9位又分为两种类型 6个状态标志位（CF SF AF PF OF ZF）表示运算结果的特征 3个控制标志位（IF TF DF）表示处理器当前的工作状态 状态标志位CF：进位标志位 加(减)法运算时，若最高位有进(借)位，则CF=1 OF：溢出标志位 当算术运算的结果超出了有符号数的可表达范围时，OF=1 ZF：零标志位 当运算结果为零时ZF=1 SF：符号标志位 当运算结果的最高位为1时，SF=1 （对于16位数，它的第15位是1，SF=1，对于8位数，第7位是1，SF=1） *下面两个状态标志位只针对8位有效 PF：奇偶标志位 运算结果的低8位中”1”的个数为偶数时PF=1 AF：辅助进位标志位 加(减)操作中，若Bit3(第三位)向Bit4(第四位)有进位(借位)，AF=1 控制标志位TF：陷阱标志位，也叫跟踪标志位 TF=1时，使CPU处于单步执行指令的工作方式 IF：中断允许标志位 IF=1使CPU可以响应可屏蔽中断请求 DF：方向标志位 在数据串操作时确定操作的方向 段寄存器段寄存器中的内容为相应逻辑段的段基地址： CS：代码段寄存器 存放代码段的段基地址 DS：数据段寄存器 存放数据段的段基地址 ES：附加段寄存器 SS：堆栈段寄存器 段寄存器的值表明相应逻辑段在内存中的位置 IP和CS决定了下一条要取的指令在内存中的位置","link":"/index/8783/"},{"title":"JS封装表单验证工具","text":"validate.js 123456789101112131415161718192021222324252627282930313233343536373839// 验证邮箱const email = email =&gt; { const reg = /^([a-zA-Z]|[0-9])(\\w|\\-)+@[a-zA-Z0-9]+\\.([a-zA-Z]{2,4})$/; if(reg.test(email)) return true return false}// 验证最小长度const min = (str, len) =&gt; { if(str.length &gt;= len) return true return false}// 验证最大长度const max = (str, len) =&gt; { if(str.length &lt;= len) return true return false}// 是否是相同的字符串const confirm = (str1, str2) =&gt; { if(str1 == str2) return true return false}// 验证手机号const phone = phone =&gt; { const reg = /^1[3-9][0-9]{9}$/; if(reg.test(phone)) return true return false}module.exports = { email, min, max, confirm, phone} 使用示例（小程序） 12345678910111213141516171819202122232425262728293031323334353637383940414243const validate = require('../../utils/validate')checkInput() { // 收集表单数据 const {name, email, password, password_confirmation} = this.data // 对表单数据进行验证 const checkName = validate.min(name, 2) const checkEmail = validate.email(email) const checkPassword = validate.min(password, 6) const checkConfirm = validate.confirm(password, password_confirmation) // 验证用户名 if(!checkName) { this.setData({error_name: '昵称最少两个字符'}) } else { this.setData({error_name: ''}) } // 验证邮箱格式 if(!checkEmail) { this.setData({error_email: '邮箱格式不正确'}) } else { this.setData({error_email: ''}) } // 验证密码格式 if (!checkPassword) { this.setData({ error_password: '密码最少6位'}) } else { this.setData({error_password: ''}) } // 确认密码 if (!checkConfirm) { this.setData({ error_password_confirm: '两次密码不一致'}) } else { this.setData({error_password_confirm: ''}) } // 全部验证通过返回 true if(checkName &amp;&amp; checkEmail &amp;&amp; checkPassword &amp;&amp; checkConfirm) return true return false}","link":"/index/ad29/"},{"title":"C语言数组之表驱动法","text":"引用百度百科的介绍：表驱动法是一种使你可以在表中查找信息，而不必用很多的逻辑语句（if或Case）来把它们找出来的方法。事实上，任何信息都可以通过表来挑选。在简单的情况下，逻辑语句往往更简单而且更直接。但随着逻辑链的复杂，表就变得越来越富有吸引力了。 下面例子通过表驱动法判断每个月的天数，不需要使用很多的if判断。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int days_of_month(int month, int year);bool is_leap(int year);int main() { printf(&quot;本月共%d天\\n&quot;, days_of_month(2, 2022)); return 0;}// 返回每个月的天数int days_of_month(int month, int year) { int is_leap_res = is_leap(year); int day_array[12] = {31, is_leap(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; return day_array[month-1];}// 计算该年份是闰年者平年bool is_leap(int year) { if (year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0)) { return true; } else { return false; }} 文章参考：C语言教程（全网最具有比喻形象的）：持续更新ing_哔哩哔哩_bilibili","link":"/index/bee/"},{"title":"JS计算时间差（天、小时、分钟前）","text":"1&lt;view&gt;{{time.getDateDiff(nowTime, timeStamp)}}&lt;/view&gt; nowTime 当前时间 timeStamp 传入的时间戳数据 12345678910111213141516171819202122232425var getDateDiff = function(nowTime, timeStamp){ let minute = 1000 * 60; let hour = minute * 60; let day = hour * 24; let diffValue = nowTime - timeStamp; let minC = diffValue / minute; let hourC = diffValue / hour; let dayC = diffValue / day; // var currentTime = parseInt(diffValue / minute) if (minC &lt; 60) { return parseInt(minC) + &quot;分钟前&quot;; } else if (minC &gt; 60 &amp;&amp; hourC &lt; 24) { return parseInt(hourC) + &quot;小时前&quot;; } else if (hourC &gt;= 24) { return parseInt(dayC) + &quot;天前&quot;; } else return} module.exports = { getDateDiff: getDateDiff};","link":"/index/f9fd/"},{"title":"git常用命令","text":"持续更新中… git init 初始化本地git仓库 git remote add origin 远程仓库地址 把本地仓库和远程仓库关联 git add 文件名 把工作区文件加入到索引区 git add . 把所有文件加入到索引区 git commit 提交到本地仓库 -m “提交信息” git commit --amend 追加提交 git status 查看文件的状态 git push 推送到远程仓库，第一次推送需要加-u origin 分支名 git clone 仓库地址 克隆远程仓库，后面可以加文件名用于保存 git pull 从远程仓库拉取 git fetch 获取远程仓库的最新历史记录 git branch 查看当前分支，加-a查看所有分支 git checkout 分支名 切换分支 git checkout 撤销修改 git reset 修改提交历史 git reset --hard 加id 撤回到之前提交的状态 git log 查看提交记录 git reflog 查看所有分支的所有操作记录（包括已经被删除的 commit 记录和 reset 的操作） git merge origin 分支名 合并远程数据库的历史记录 Git配置及其他： git config --global user.name &quot;&lt;用户名&gt;&quot; 设置用户名 git config --global user.email &quot;&lt;邮箱&gt;&quot; 设置邮箱 git config --global alias.st status 给命令配置简写，此处将status简写为st","link":"/index/3b9/"},{"title":"JS模块化，require、import和export","text":"require遵循AMD规范，在运行时加载，可以将js文件以模块的方式引入。 12345// 引入hello模块const hello = require('./hello');// 调用hello模块中使用exports暴露的world()方法hello.world(); export 导出模块导出模块，export语法声明用于导出函数、对象、指定文件（或模块）的原始值。 123456789101112131415161718192021222324252627// 导出单个特性export let name1, name2, …, nameN; // also var, constexport let name1 = …, name2 = …, …, nameN; // also var, constexport function FunctionName(){...}export class ClassName {...}// 导出列表export { name1, name2, …, nameN };// 重命名导出export { variable1 as name1, variable2 as name2, …, nameN };// 解构导出并重命名export const { name1, name2: bar } = o;// 默认导出export default expression;export default function (…) { … } // also class, function*export default function name1(…) { … } // also class, function*export { name1 as default, … };// 导出模块合集export * from …; // 不设置默认导出export * as name1 from …;export { name1, name2, …, nameN } from …;export { import1 as name1, import2 as name2, …, nameN } from …;export { default } from …; nameN 要导出的标识符，以便在其他文件通过 import 引用。 from 从已经存在的模块、脚本文件…导出。 export有两种模块导出方式：命名式导出（名称导出）和默认导出（定义式导出），命名式导出每个模块可以多个，而默认导出每个模块仅一个。 命名导出： 1234567// 导出事先定义的特性export { myFunction，myVariable };// 导出单个特性（可以导出var，let，//const,function,class）export let myVariable = Math.sqrt(2);export function myFunction() { ... }; 默认导出： 12345678// 导出事先定义的特性作为默认值export { myFunction as default };// 导出单个特性作为默认值export default function () { ... }export default class { .. }// 每个导出都覆盖前一个导出 在导出多个值时，命名导出非常有用。在导入期间，必须使用相应对象的相同名称，但是，可以使用任何名称导入默认导出。 exports和module.exportsmodule.exports 对象是由模块系统创建的，在我们自己写模块的时候，需要在模块最后写好模块接口，声明这个模块对外暴露什么内容，module.exports 提供了暴露接口的方法。 返回JSON对象： 12345678var app = { name: 'app', version: '1.0.0', sayName: function(name){ console.log(this.name); }}module.exports = app; 这种方法可以返回全局共享的变量或者方法。 调用： 12var app = require('./app.js');app.sayName('hello'); 返回函数： 1234567891011var func1 = function() { console.log(&quot;func1&quot;);}; var func2 = function() { console.log(&quot;func2&quot;);}; exports.function1 = func1;exports.function2 = func2; 调用： 123var functions = require(&quot;./functions&quot;);functions.function1();functions.function2(); 返回一个构造函数： 1234var CLASS = function(args){ this.args = args;}module.exports = CLASS; 调用： 12var CLASS = require('./CLASS.js');varc = new CLASS('arguments'); 返回一个实例对象： 12345678//CLASS.jsvar CLASS = function(){ this.name = &quot;class&quot;;}CLASS .prototype.func = function(){ alert(this.name);}module.exports = new CLASS(); 调用： 12var c = require('./CLASS.js');c.func(); 两者区别： 12345// exports 返回的是模块函数，方法可以直接调用exports.[function name] = [function name]// moudle.exports 返回的是模块对象本身，返回的是一个类，需要new对象之后才可以调用moudle.exports = [function name] import 引入模块import语法声明用于从已导出的模块、脚本中导入函数、对象、指定文件（或模块）的原始值。 import模块导入与export模块导出功能相对应，也存在两种模块导入方式：命名式导入（名称导入）和默认导入（定义式导入）。 import的语法跟require不同，而且import必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。 1234567891011121314151617import defaultExport from &quot;module-name&quot;;// 导入整个模块的内容import * as name from &quot;module-name&quot;;// 导入单个接口import { export } from &quot;module-name&quot;;import { export as alias } from &quot;module-name&quot;;// 导入多个接口import { export1 , export2 } from &quot;module-name&quot;;import { foo , bar } from &quot;module-name/path/to/specific/un-exported/file&quot;;import { export1 , export2 as alias2 , [...] } from &quot;module-name&quot;;import defaultExport, { export [ , [...] ] } from &quot;module-name&quot;;import defaultExport, * as name from &quot;module-name&quot;;import &quot;module-name&quot;; defaultExport 导入模块的默认导出接口的引用名。 module-name 要导入的模块。通常是包含目标模块的.js文件的相对或绝对路径名，可以不包括.js扩展名。某些特定的打包工具可能允许或需要使用扩展或依赖文件，它会检查比对你的运行环境。只允许单引号和双引号的字符串。 name 导入模块对象整体的别名，在引用导入模块时，它将作为一个命名空间来使用。 export, exportN 被导入模块的导出接口的名称。 alias, aliasN 将引用指定的导入的名称。 文章参考CSDN： 终于讲清楚了nodejs中exports和module.exports的区别_嘿嘿-CSDN博客 MDN文档： import - JavaScript | MDN (mozilla.org) MDN文档： export - JavaScript | MDN (mozilla.org) END","link":"/index/9169/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/index/3eeb/"},{"title":"Nodejs + MongoDB模糊搜索","text":"MongoDB中模糊查询要使用正则表达式，使用nodejs和mongodb实现一个通过搜索框对数据库进行搜索的功能，一开始直接用的findOne()方法 123Corpus.findOne({name: '/'+req.query.name.replace(/&quot;/g, '')+'/'}, function (err, Corpus) { ...}) 很奇怪，这种方式并查不到东西，把name对应的值写死后，却可以正常查到内容，但是req.query.name是可以正常获取到前台输入的内容的。 解决：在nodejs中要用RegExp构建正则表达式对象 1234567let CorpusSearch = req.query.name.replace(/&quot;/g, '')let str = &quot;.*&quot;+CorpusSearch+&quot;.*$&quot;let reg = new RegExp(str)Corpus.find({name:{$regex:reg, $options: 'i'}}, function (err, Corpus) { ...}) 功能完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344.get('/Corpus', function(req, res) { if (req.query.name != null &amp;&amp; req.query.name != undefined &amp;&amp; req.query.name != '') { let CorpusSearch = req.query.name.replace(/&quot;/g, '') let str = &quot;.*&quot;+CorpusSearch+&quot;.*$&quot; let reg = new RegExp(str) Corpus.find({name:{$regex:reg, $options: 'i'}}, function (err, Corpus) { if (err) { return res.status(500).send('Server error') } // console.log(Corpus) if (Corpus == undefined) { res.render('Corpus.html', { count: 0, Corpus: Corpus }) } else { let str = JSON.stringify(Corpus) Corpus = JSON.parse(str) res.render('Corpus.html', { count: 1, Corpus: Corpus }) } }) } else { Corpus.find(function (err, CorpusData) { if (err) { return res.status(500).send('Server error') } if (CorpusData.length &gt;= 3) { var top = [ CorpusData[0], CorpusData[1], CorpusData[2], ] } res.render('Corpus.html', { top: top, Corpus: CorpusData }) }) }}) END","link":"/index/d05c/"},{"title":"vue练习_时钟案例","text":"结果演示 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src=&quot;../vue.min.js&quot;&gt;&lt;/script&gt; &lt;style&gt; #app { background-color: #333333; color: #fff; font-size: 66px; text-align: center; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; {{date | formatDate }} &lt;/div&gt; &lt;script&gt; function padDate(value) { return value &lt; 10 ? &quot;0&quot; + value : value; } var vm = new Vue({ el: '#app', data: { date: new Date(), }, filters: { formatDate: function(value) { var date = new Date(value); var year = date.getFullYear(); var month = padDate(date.getMonth()+1); var day = padDate(date.getDate()); var hour = padDate(date.getHours()); var minute = padDate(date.getMinutes()); var second = padDate(date.getSeconds()); // 返回格式化完成的数据 return year + '-' + month + '-' + day + '-' + '-' + hour + ':' + minute + ':' + second; } }, mounted:function() { var currentVmObj = this; this.trimer = setInterval(function() { currentVmObj.date = new Date(); },1000); }, beforeDestroy:function() { // 关闭时钟器 if(this.timer != null) { clearInterval(this.timer) } } }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; END","link":"/index/444/"},{"title":"使用GitHub托管自己的静态网站","text":"GitHub Pages是一个免费的静态网站托管服务，不需要准备服务器和域名，可以直接部署静态网站 所需工具Git、VS Code、浏览器 在GitHub新建一个仓库打开GitHub，点击右上角头像左边的 + 号，点击New repository Repository name是仓库名称，Description是仓库描述 信息填好后，点击绿色Create repository按钮 创建完成后会看到这个页面，里面有一些Git命令，引导你你怎样将本地的文件上传 配置Git账户如果刚安装完Git，那么在上传之前需要配置一下Git账户，在本地生成用户名和邮箱，如果已经配置好可以略过此步 123$ ssh-keygen #用于生成本地ssh公钥，运行完后一路回车即可$ git config --global user.name &quot;这里输入用户名&quot; #Github的用户名$ git config --global user.email &quot;这里输入邮箱&quot; #注册GitHub时的邮箱 上传本地文件在VS Code中打开终端，点击上方终端→新终端，或者按Ctrl+Shift+` 在终端输入命令： 1$ git init #初始化仓库 这时VS Code左侧的源代码管理功能会出现数字，就是本地未提交的文件 本地仓库创建好后，我们需要与之前在Github建立的仓库进行关联，刚才在GitHub建立仓库完成后的页面有一条命令： 直接复制这条命令在终端运行，如果仓库中看不到这些命令，那么复制下面这条命令，后边加上GitHub仓库的HTTPS地址（.git结尾的那个） 1$ git remote add origin 之后就是输入提交信息并推送，命令方法如下： 123$ git add . #添加现有文件$ git commit -m &quot;你想说的话&quot; #创建提交注释信息$ git push -u origin main #提交仓库到远程main分支 也可以使用图形化的VS Code的源代码管理功能进行推送，点击左侧源代码管理，在输入框中可以填写提交信息，相当于命令行的git commit -m，下方是待更改的文件 输入完提交信息后，点击✔，在弹出的框选是 这时之前待更改的文件都消失了，如果还要修改一些里面的文件，修改后的文件还会在这里显示，现在只是在本地仓库提交，我们需要推送到远程，点击三个点...的按钮，里面有一个推送的选项，点击推送 点击推送后，第一次会弹出选项框，提示master没有上游分支，点击确定 点击确定后如果是第一次使用会弹出网页进行授权，按提示操作即可 再去刷新刚才的GitHub页面，可以看到刚才的文件已经提交上去了 设置GitHub Pages点击Settings，向下滑，找到Github Pages 将Source的None选项改为master 这时网页会自动刷新，上方会出现一个链接 点击链接，网页就可以通过GitHub访问了 文章参考CSDN 干巴爹兔 https://blog.csdn.net/qq_18297883/article/details/106653698","link":"/index/4684/"},{"title":"vue生命周期钩子","text":"Vue生命周期是指Vue实例从创建到销毁的过程，其中包括了一系列的生命周期钩子函数，让代码在特定阶段运行。Vue生命周期总共可以分为8个阶段：创建前后,载入前后,更新前后,销毁前销毁后。生命周期会在调用app.mount()之后开始，直到调用app.unmount()结束。 常用的生命周期钩子是created和mounted，这两个生命周期中请求数据有什么区别呢？一般来说，在created中请求数据比较合适，因为此时组件已经完成了数据观测和事件配置，而且不依赖于DOM元素。而在mounted中请求数据可能会导致页面渲染延迟或者重复渲染。 八个Vue生命周期方法beforeCreate()钩子是在调用app.mount()创建Vue实例之后，createApp()中的配置项生效之前调用。 created()钩子是在beforeCreate()之后，createApp()中的配置项生效之后调用，这个时候计算属性、方法、watcher监听器已经配置好了。 beforeMount()在created生命周期执行完成之后，应用还没有挂载到app.mount()指定的HTML元素上，在挂在之前会调用beforeMount()生命周期钩子，这个时候应用还没在页面上渲染出来。 mounted()会在应用挂载到app.mount()指定的HTML元素之后执行，这个时候应用已经在页面上渲染出来了。 beforeUpdate()当应用中的HTML模板需要重新渲染时，例如data中的属性发生了变化，那么在刷新之前会执行beforeUpdate()生命周期钩子。 updated()是在数据更新后、HTML重新渲染完成之后调用。 beforeUnmount()会在应用卸载前执行，调用app.unmount()会卸载组件，那么在正式卸载前，先执行beforeUnmount()生命周期钩子，这个时候Vue应用还是正常的，可以在里边做一些清理收尾操作。 unmounted()生命周期会在应用正式卸载之后调用，这个时候跟应用有关的事件监听，或者指令绑定都已经卸载了。 END","link":"/index/e9c6/"},{"title":"小程序封装request请求工具","text":"使用示例 统一管理API ： 1234const request = require('../utils/request')// 首页数据export const getIndexData = (data = {}) =&gt; request.get('/api/index', data, false) 在页面对应的js中引用： 1import {getIndexData} from &quot;../../service/index&quot;; request.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import checkLogin from &quot;./checkLogin&quot;;import {baseUrl} from &quot;./config&quot;; // 接口url地址const toast = (title, reject) =&gt; { wx.showToast({ title, icon: 'none' }) reject(title)}const request = (url, method = &quot;GET&quot;, data = {}, isLoading = true) =&gt; { return new Promise((resolve, reject) =&gt; { if (isLoading) { wx.showLoading({title: '加载中..'}) } wx.request({ url: baseUrl + url, method, data, header: { Authorization: 'Bearer ' + wx.getStorageSync('access_token') || '' }, success(res) { let msg = '' const {statusCode} = res // 400以下都是成功返回了 if (statusCode &lt; 400) { resolve(res.data) } else if (statusCode === 400) { // 请求错误, 服务器返回了错误信息 msg = res.data.message } else if (statusCode === 401) { // 未认证(未登录), token过期等 // 用户账号密码错误 if (res.data.message == 'Unauthorized') { msg = '账号密码错误' } else { // 用户没有token, 或者token无效, 重定向登录页面 // 清空原来缓存的登录信息 wx.removeStorageSync('access_token') wx.removeStorageSync('userInfo') // 缓存来源地址, 并跳转到登录 checkLogin() } } else if (statusCode === 403) { // 没有权限 msg = '没有权限' } else if (statusCode === 404) { // 资源不存在 msg = '未找到资源' } else if (statusCode === 422) { // 表单验证未通过 const {errors} = res.data msg = errors[Object.keys(errors)[0]][0] } else if (statusCode === 429) { // 请求频率过快 msg = '请稍后再试' } else { msg = '请求异常' } // 统一提示 if(msg) toast(msg, reject) }, fail(e) { toast('服务器异常') reject(e) }, complete() { wx.hideLoading() } }) })}const e = { request, get: (url, data = {}, isLoading = true) =&gt; request(url, 'GET', data, isLoading), post: (url, data = {}, isLoading = true) =&gt; request(url, 'POST', data, isLoading), patch: (url, data = {}, isLoading = true) =&gt; { // 微信小程序不支持patch请求, 要处理一下 data = { ...data, _method: 'PATCH' } // 使用post请求, 请求参数中的 _method 可以模拟要请求的方法, put patch delete 等 return request(url, 'POST', data, isLoading) }, put: (url, data = {}, isLoading = true) =&gt; request(url, 'put', data, isLoading), delete: (url, data = {}, isLoading = true) =&gt; request(url, 'DELETE', data, isLoading),}module.exports = e","link":"/index/ac11/"},{"title":"我的第一篇博客","text":"测试 内容 阿巴阿巴阿巴 END","link":"/index/f929/"}],"tags":[{"name":"微机原理","slug":"微机原理","link":"/tags/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"},{"name":"前端","slug":"frontend","link":"/tags/frontend/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"小程序","slug":"小程序","link":"/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}],"categories":[{"name":"学习笔记","slug":"notes","link":"/categories/notes/"}]}